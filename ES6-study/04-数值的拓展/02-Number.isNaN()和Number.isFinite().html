<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Number.isNaN()和Number.isFinite()</title>
</head>
<body>
<script type="text/javascript">
    //Number.isFinite() 用来判断一个数组是不是有限的
    //如果传入的参数是一个字符串，那么会直接输出false
    Number.isNaN(15)//false
    Number.isFinite(15); // true
    Number.isFinite(0.8); // true
    Number.isFinite(NaN); // false
    Number.isFinite(Infinity); // false
    Number.isFinite(-Infinity); // false
    Number.isFinite('foo'); // false
    Number.isFinite('15'); // false
    Number.isFinite(true); // false

    // Number.isNaN()用来检查一个值是否为NaN。not a number
    Number.isNaN(NaN) // true
    Number.isNaN(15) // false
    Number.isNaN('15') // false
    Number.isNaN(true) // false
    Number.isNaN(9 / NaN) // true
    Number.isNaN('true' / 0) // true
    Number.isNaN('true' / 'true') // true

    /*对传统的全局方法isNaN和isFinite来说，如果传入的参数不是数值，会先转化为数值
    * 但是对于这两个新的方法来说,只要传入的参数不是数值, 就会直接返回false
    * */

    //将parseInt和parseFloat移植到了Number身上,内容完全保持一致
    // ES5的写法
    parseInt('12.34') // 12
    parseFloat('123.45#') // 123.45

    // ES6的写法
    Number.parseInt('12.34') // 12
    Number.parseFloat('123.45#') // 123.45

    //Number.isInteger()
    Number.isInteger(452)//true
    Number.isInteger(452.0)//true
    Number.isInteger(452.0)//true
    // 如果参数不是数值，Number.isInteger返回false。
    Number.isInteger('222')//false

    let a = 0.1 + 0.2 - 0.3

    //表示1与大于一的最小浮点数之间的差值
    /*常常用来设置误差能够接受的范围*/
    console.log(Number.EPSILON);
    Number.prototype.isAccepted = function () {
        return (typeof this === 'number' && this < Number.EPSILON * Math.pow(2, 2))
    }

    console.log(a.isAccepted());


</script>

</body>
</html>